[
    {
        "title": "MyProgram.S",
        "optionName": "New Program",
        "isNewProgram": true,
        "text": "# static data declarations begin at .data\n.data\n\t\n# program text begins at .text\n.text\n\n# define global function main\n.globl main\n\n# program begins execution at main\nmain:\n\t\n\tjr\t$ra\t\t\t# Exit\n",
        "cycles" : 150
    },
    {
        "title": "HelloWorld.S",
        "optionName": "Hello World",
        "text": "# static data declarations begin at .data\n.data\n\tmsg:\t.asciiz\t\t\"Hello World!\\n\"\n\n# program text begins at .text\n.text\n\n# define global function main\n.globl main\n\n# program begins execution at main\nmain:\n\tla\t$a0, msg\t# $a0 = address of message\n\tli\t$v0, 4\t\t# $v0 = 4: print string code\n\tsyscall\t\t\t# print msg\n\tjr\t$ra\t\t\t# Exit\n",
        "cycles": 100
    },
    {
        "title": "Showcase.S",
        "optionName": "Showcase",
        "text": "##################################################\n# Showcase.S                                     #\n# A shallow, interactive decision tree program   #\n# peaking into a few this unit's capabilities as #\n# a demonstration of its potential to execute    #\n# more complex programs                          #\n##################################################\n\n# data declarations begin at .data\n.data\n\thello:\t.asciiz \"Hello, World!\"\n\n\toptions_msg:\t.asciiz \"\\n\\nPlease Enter a number to select an option:\\n 1. How am I seeing this text?\\n 2. Tell me a joke\\n 3. Why so slow?\\n 4. Exit\\n\"\n\n\texplanation_msg: .asciiz \"1's and 0's have been compiled from the MIPS assembly language, and they are being run through a LOT of simulated logic gates and hardware components to mimic the actual datapath of MIPS architecture.\"\n\n\twhy_so_slow_msg: .asciiz \"Computers use parallel wires to carry many signals at the same time. In order to simulate the datapath of a MIPS computer as closely as possible in JavaScript, this computer simulates the signals in each of its hundreds of wires, but can only do so in series - one after another. This lack of parallelism is a major cause of it being about 2,000,000 times slower than an actual computer.\"\n\n\tjoke_msg: .asciiz \"Why was the computer late?\\n\\nIt had a hard drive.\"\n\n\tgoodbye: .asciiz \"Goodbye!\\n\"\n\t\n# program text begins at .text\n.text\n\n# declare global function main\n.globl main\n\n# program execution starts at main\nmain:\n\tli\t$v0, 4\t# $v0 = 4 - print string syscall\n\n\t# Hello! :)\n\tla\t$a0, hello\t# $a0 = addr of hello (for print string syscall)\n\tsyscall\t\t\t# print hello\n\t\n\tj\toptions\t\t# jump to options\n\n# List option menu for user\n# expects $v0 to already equal 4 (for print string)\noptions:\n\tla\t$a0, options_msg\t# $a0 = addr of options_msg - for print string syscall\n\tsyscall\t# print options_msg\n\tli\t$v0, 5\t# $v0 = 5 - for read int syscall\n\tsyscall\t# read int\n\n\tmove\t$t0, $v0\t# $t0 = user input int\n\tli\t\t$v0, 4\t\t# $v0 = 4 (for next print string)\n\n\tli\t$t1, 1\t# $t1 = 1 (option comparison)\n\tbeq\t$t0, $t1, explanation\t# branch to explanation if user input = 1\n\tli\t$t1, 2\t# $t1 = 2 (option comparison)\n\tbeq\t$t0, $t1, joke\t\t# branch to joke if user input = 2\n\tli\t$t1, 3\t# $t1 = 3 (option comparison)\n\tbeq\t$t0, $t1, whysoslow\t# branch to whysoslow if user input = 3\n\tli\t$t1, 4\t# $t1 = 4 (option comparison) \n\tbeq\t$t0, $t1, Exit\t\t# exit if user input = 4\n\tj\toptions\t# repeat options if user input invalid option\n\n# give simple explanation for what computer does\n# expects $v0 to already equal 4 (for print string)\nexplanation:\n\tla $a0, explanation_msg\t# $a0 = addr of explanation_msg - for print string syscall\n\tsyscall\t\t# print explanation_msg\n\tj\toptions\t# display options again\n\n# tell hilarious joke\n# expects $v0 to already equal 4 (for print string)\njoke:\n\tla\t$a0, joke_msg\t# $a0 = addr of joke_msg - for print string syscall\n\tsyscall\t\t# print explanation_msg\n\tj\toptions # display options again\n\n# explains why computer is so slow \n# \t(I really just wanted another option)\n# expects $v0 to already equal 4 (for print string)\nwhysoslow:\n\tla \t$a0, why_so_slow_msg\t# $a0 = addr of why_so_slow_msg - for print string syscall\n\tsyscall\t\t\t# print why_so_slow_msg\n\tj\toptions\t\t# display options again\n\n# exit program\n# expects $ra to be preserved\nExit:\n\tli\t$a0, 4\t\t\t# $v0 = 4 (for print string)\n\tla\t$a0, goodbye\t# $a0 = addr of goodbye\n\tsyscall\t\t\t\t# print goodbye\n\tjr\t$ra\t \t\t\t# exit\n",
        "cycles" : 1100
    },
    {
        "title": "Instructions.S",
        "optionName": "Instructions",
        "text": "##################################################\n# Instructions.S\t\t\t\t\t\t\t\t #\n# Examples and explanations of all supported\t #\n# instructions and several use cases\t\t\t #\n##################################################\n\n.data\t# static data declarations begin at .data\n\n# supported data types:\n\nword1:\t\t# declare word1\n\t.word\t# 32-bit integer; -2147483648 - +2147483647\n\t\t123 # word1 = 123\n\nhalf1:\t\t# declare half1\n\t.half\t# 16-bit integer; -65536 - +65535\n\t\t0xa\t# half1 = 0xa = 10\n\nbyte1:\t\t# declare byte1\n\t.byte\t#\t8-bit integer; -128 - +127\n\t\t12\t# byte1 = 12\n\nasciiz1:\t# declare asciiz1\n\t.asciiz \t# asciiz string\n\t\t\"Hello!\"\t# asciiz1 = \"Hello!\"\n\nascii1:\t\t# declare ascii1\n\t.ascii\t\t# compiled to be standard asciiz string\n\t\t\"Hello again!\" # ascii1 = \"Hello again!\"\n\n# arrays:\n\narr1:\t# declare arr1\n\t.word\n\t\t1, 2, 3, 4\t# arr1 = 1, 2, 3, 4\n\narr1_len:\t# declare arr1_len\n\t.word\n\t\t4\t# arr1_len = length of arr1 - 4\n\n\n.text\t# program text begins at .text\n\n.globl\t# .globl keyword defines global symbols (main)\n\tmain\t# begin program execution at global symbol main\n\n# program execution begins at main\nmain:\n\tli\t$t0, 100\t\t# $t0 = 100\n\taddi $t1, $t0, 4\t# $t1 = $t0 + 4\n\tadd $t2, $t0, $t1\t# $t2 = $t0 + $t1\n\tli\t$t1, 0x7fffffff # $t0 = 0x7fff ffff - largest possible signed integer\n\taddu $t0, $t1, $t2\t# add without overflow trap\n\tand $t0, $t1, $t2\t# $t0 = $t1 bitwise AND $t2\n\tandi $t0, $t1, 11\t# $t0 = $t1 bitwise AND 11\n\tbeq $t0, $t1, function1 # branch to function1 IF $t0 = $t1\n\tbne $t0, $t1, function1 # branch to function1 IF $t0 ≠ $t1\n\nfunction1:\n\tb\tfunction2\t# branch to function2\n\nfunction2:\n\t# PUSH $ra to stack\n\taddi $sp, $sp, -4\t# decrement stack pointer 4\n\tsw\t$ra, 0($sp)\t# M[$sp] = $ra\n\n\tjal function3\t# jump to function4, and set $ra = address to return to (PC + 4)\n\n\t# POP $ra from stack\n\tlw\t$ra, 0($sp)\t# $ra = M[$sp]\n\taddi $sp, $sp, 4\t# increment stack pointer 4\n\n\tj\tfunction4\t# jump to function4\n\nfunction3:\n\tjr\t$ra\t\t# jump to return address (last jal)\n\nfunction4:\n\tlui $t0, 100\t# $t0 = 100 << 16\n\tnor $t0, $t1, $t2\t# $t0 = $t1 bitwise NOR $rt\n\tor\t$t0, $t1, $t2\t# $t0 = $t1 bitwise OR $rt\n\tori $t0, $t1, 100\t# $t0 = $t1 bitwise OR 100\n\tslt $t0, $t1, $t2\t# $t0 = 1 if $t1 < $t2, 0 if $t1 ≥ $t2\n\tslti $t0, $t1, 100\t# $t0 = 1 if $t1 < 100, 0 if $t1 ≥ 100\n\tsll $t0, $t1, 4\t # $t0 = $t1 << 4\n\tsrl $t0, $t1, 4\t # $t0 = $t1 >> 4\n\n\t# syscall ops:\n\t# $v0 = 1:\tprint int in $a0\n\t# $v0 = 4:\tprint nul-terminated string (asciiz) with initial address in $a0\n\t# $v0 = 5:\tread int; stored in $v0\n\t# $v0 = 8:\tread string; initial address stored in $a0, length stored in $a1\n\t# $v0 = 10: EXIT\n\t# note on machine code: \n\t# the syscall machine code for this computer compiles into 0xc482 0000, not the standard 0x0000 000c.\n\t# This is because syscall on an actual MIPS CPU is immensely more complicated, supporting 50+ operations depending on the implementation. For the 5 syscall operations this chip needed to implement, 0xc482 0000 proved to be a good operation, which initially follows the datapath of lw $v0, 0($a0) until intervention from syscall control wires.\n\n\tli\t$v0, 1\t\t# $v0 = 1 - opcode for print int syscall\n\tla\t$t0, word1\t# $t0 = address of word1\n\tlw\t$a0, 0($t0) # $a0 = word1\n\tsyscall\t\t # call syscall - print int $a0 (word1)\n\n\tli\t$v0, 4\t\t\t# $v0 = 4 - opcode for print string syscall\n\tla\t$a0, asciiz1\t# $a0 = address of asciiz1\n\tsyscall\t\t\t # call syscall - print string at address $a0 (asciiz1)\n\n\t# print each word in arr1:\n\tla\t$a0, arr1\t\t# $a0 = address of arr1 - argument 1 for print_word_array\n\tla\t$t0, arr1_len\t# $t0 = address of arr1_len\n\tlw\t$a1, 0($t0)\t # $a1 = arr1 - argument 2 for print_word_array\n\t\n\n\t# PUSH $ra to stack\n\taddi $sp, $sp, -4\t# decrement stack pointer 4\n\tsw\t$ra, 0($sp)\t# M[$sp] = $ra\n\n\tjal print_word_array # print word array with start address $a0, length $a1\n\n\t# POP $ra from stack\n\tlw\t$ra, 0($sp)\t# $ra = M[$sp]\n\taddi $sp, $sp, 4\t# increment stack pointer 4\n\n\t\n\t# pseudo\n\t# these are operations that have no designated datapath inside the computer - the assembler compiles them into instructions that perform their semantic meaning\n\tnop\t # \"no op(code)\" - performs no operation - a pipeline stall / bubble\n\t\t\t# actual instruction: sll\t$zero, $zero, 0\n\tmove\t$t0, $t1\t# $t0 = $t1\n\t\t\t\t\t\t# actual instruction: add $t0, $t1, $zero\n\tli\t\t$t0, 65536\t# $t0 = 65536\n\t\t\t\t\t\t# actual instructions:\n\t\t\t\t\t\t# lui\t$t0, [upper 16 bits of 65536]\n\t\t\t\t\t\t# ori\t$t0, [lower 16 bits of 65536]\n\tla\t\t$t0, byte1\t# $t0 = address of byte1\n\t\t\t\t\t\t# actual instruction:\n\t\t\t\t\t\t# addi\t$t0, $gp, [compiler-inserted offset]\n\tblt\t $t0, $t1, exit # branch to exit IF $t0 < $t1\n\t\t\t# actual instructions:\n\t\t\t# slt\t$at, $t0, $t1\n\t\t\t# bne\t$at, $zero, exit\n\tble\t $t0, $t1, exit # branch to exit IF $t0 ≤ $t1\n\t\t\t# actual instructions:\n\t\t\t# slt\t$at, $t1, $t0\n\t\t\t# beq\t$at, $zero, exit\n\tbgt\t $t0, $t1, exit # branch to exit IF $t0 > $t1\n\t\t\t# actual instructions:\n\t\t\t# slt\t$at, $t1, $t0\n\t\t\t# bne\t$at, $zero, exit\n\tbge\t $t0, $t1, exit # branch to exit IF $t0 ≥ $t1\n\t\t\t# actual instructions:\n\t\t\t# slt\t$at, $t0, $t1\n\t\t\t# beq\t$at, $zero, exit\n\n# EXIT program\n# Expects $ra to be initial return address - address of EXIT program\nexit:\n\tjr\t$ra # jump to (initial) return address - address of EXIT program\n\n# print word array:\n# arguments:\n# $a0: ADDRESS of array\n# $a1: LENGTH of array\nprint_word_array:\n\t# PUSH $a0 to stack\n\taddi $sp, $sp, -4\t# decrement stack pointer 4\n\tsw\t$a0, 0($sp)\t# M[$sp] = $a0\n\n\tmove\t$t0, $a0\t# $t0 = ADDRESS = $a0\n\tli\t\t$t1, 0\t\t# $t1 = INDEX = 0\n\n\t# print int syscall op\n\tli\t\t$v0, 1\n\n# loop while INDEX < LENGTH\nconditional:\t# determine whether to loop or exit\n\tbge\t $t1, $a1, loop_exit # if INDEX !< LENGTH, exit\n\t# if INDEX < LENGTH\n\t# LOOP\n\n\t# content\n\tlw\t\t$a0, 0($t0) # $a0 = array[index]\n\tsyscall\t\t\t # print array[index]\n\n\t# increment / update\n\taddi\t$t1, $t1, 1 # increment INDEX\n\taddi\t$t0, $t0, 4 # increment ADDRESS 4 (1 byte)\n\n\t# loop back to conditional\n\tb\t\tconditional # branch to conditional\nloop_exit:\t# EXIT loop\n\t# POP $a0 from stack\n\tlw\t\t$a0, 0($sp)\t# $a0 = M[$sp]\n\taddi\t$sp, $sp, 4\t# increment stack pointer 4\n\n\tjr\t$ra\t\t# return\n",
        "cycles" : 250
    }
]